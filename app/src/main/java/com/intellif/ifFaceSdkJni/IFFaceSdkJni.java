package com.intellif.ifFaceSdkJni;

public class IFFaceSdkJni {
    private static IFFaceSdkJni sInstance = null;

    public IFFaceSdkJni() {
    }

    public static IFFaceSdkJni getInstance() {
        if (sInstance == null) {
            sInstance = new IFFaceSdkJni();
        }

        return sInstance;
    }
    static {
        System.loadLibrary("if_face_sdk_jni");
    }
    /**
     * get sdk version and time
     * @return the string of (version_time)
     */
    public native String ifGetVersion();

    /**
     * get signature to require license
     * @return the string of signature, if failed return ""
     */
    public native String ifGetSignature();

    /**
     * initialize sdk with models. If you do not use a model, set its pointer to null
     * @param[in]  license      sdk license, give signature to intellif obtain license
     * @return     valid data (yyyy-mm-dd), if license verify failed, return ""
     */
    public native String ifCheckLicense(String license);

    /**
     * set log level to print necessary information
     * @param logLevel LOG_LEVEL_ERROR=1 and LOG_LEVEL_INFO=2
     * @return
     */
    public native int ifSetLogLevel(int logLevel);

    /**
     * initialize sdk with models. If you do not use a model, set its pointer to null
     * @param[in]  FaceModels
     * @param[in]  configs, char string in json,
     *             now should be like this:
     *             {
     *                 "configDir":"/x/x/x",        //need have write permission to save license file
     *                 "serverIp":"x.x.x.x",
     *                 "serverPort":"x",
     *                 "apiKey":"xxx",
     *                 "apiSecret":"xxx"
     *             }
     * @return     error code
     */
    public native int ifInit(IFModels models, String configs);

    /**
     * release sdk
     * @return     error code
     */
    public native int ifRelease();

    /**
     * set detect config
     * @param[in]  detect_threshold         the interval [0, 1], detect face bbox threshold
     * @param[in]  quality_threshold     the interval [0, 1], face quality threshold
     * @return     error code
     */
    public native int ifSetDetectConfig(float detect_threshold, float quality_threshold);

    /**
     * convert image format form yuv-nv21 to bgr
     * @param[in]  nv21_data      yuv-nv21 image data
     * @param[in]  width the width of image
     * @param[in]  height  the height of image
     * @return     byte[]  bgr_data
     */
    public native byte[] ifNV21ToBgr(byte[] nv21_data, int width, int height);

    /**
     * detect faces from image
     * @param[in]  image      single image
     * @param[in]  face_within_thr the interval [0, 1], only reserve faces mostly inside image
     * @param[in]  min_face_h  the minimum face height size in results
     * @return     long[]     face handle array
     */
    public native long[] ifDetect(IFImage image, float face_within_thr, int min_face_h);

    /**
     * detect and track faces from sequential frames
     * @param[in]  image      frame image
     * @param[in]  face_within_thr the interval [0, 1], only reserve faces mostly inside image
     * @param[in]  min_face_h  the minimum face height size in results
     * @return     long[]     face handle array
     */
    public native long[] ifDetectAndTrack(IFImage image, float face_within_thr, int min_face_h);

    /**
     * get FaceRect with Facehandle
     * @param[in]  handle      the detected face handle
     * @return     IFRect
     */
    public native IFRect ifGetFaceRect(long handle);

    /**
     * get FaceLandmark with Facehandle
     * @param[in]  handle      the detected face handle
     * @return  IFPoint[]     landmark points, array size should be 68
     */
    public native IFPoint[] ifGetFaceLandmark(IFImage image, long handle);

    /**
     * get track id from FaceHandle, which is generated by ifDetectAndTrack interface
     * @param[in]  handle     the detected face handle
     * @return     track id
     */
    public native int ifGetTrackId(long handle);

    /**
     * reset the tracker state, remove all tracks
     * @return     error code
     */
    public native int ifResetTrack();

    /**
     * release detected face
     * @param[in]  handle           FaceHandle
     * @return     error code
     */
    public native int ifReleaseFace(long handle);

    /**
     * get quality and blurness of detected face
     * @param[in]  image      single image
     * @param[in]  handle     the detected face handle
     * @return     IFQualityBlur
     */
    public native IFQualityBlur ifGetQualityBlurAttribute(IFImage image, long handle);

    /**
     * extract feature from the detected face, used for get similar from faceGroup
     * @param[in]  image      single image
     * @param[in]  handle                 face handle
     * @return     byte[] feature, size should be 2066
     */
    public native byte[] ifExtract(IFImage image, long handle);

    /**
     * extract feature from the detected face, used for insert into faceGroup
     * @param[in]  image      single image
     * @param[in]  handle                 face handle
     * @return    byte[] feature, size should be 2066
     */
    public native byte[] ifExtractForFaceGroup(IFImage image, long handle);

    /**
     * get similarity of two features
     * @param[in]  first_feature      the feature array of one face
     * @param[in]  second_feature     the feature array of another face
     * @param[in]  feature_length     the length of feature array
     * @return     the similarity of two features [0-100]
     */
    public native float ifCompare(byte[] first_feature, byte[] second_feature, int feature_length);

    /**
     * get face mask score of detected face
     * @param[in]  image      single image
     * @param[in]  handle			 face handle
     * @return     result      0/1, 0:no mask, 1:mask
     */
    public native int ifGetFaceMask(IFImage image, long handle);

    /**
     * get ir image liveness score of detected face
     * @param[in]  image      single image
     * @param[in]  handle			 ir face handle
     * @return     result            the interval [0, 1], liveness of face
     */
    public native float ifGetLivenessIr(IFImage image, long handle);

    /**
     * filter visible face array by corresponding ir face
     * @param[in]  bgr_handle_array        	visible face handle array
     * @param[in]  ir_image         ir image (same time with bgr image which bgr_handle_array belong)
     * @param[in]  threshold     	the threshold to filter [0, 100]
     * @return     filter_result    pointer to the result, pre-allocated outside, 1 pass ir_filter, 0 failed ifIrFilter
     */
    public native int[] ifIrFilter(long[] bgr_handle_array, IFImage ir_image, float threshold);

    /**
     * create a face group
     * @param[in]  handle			face group handle
     * @return     IFFaceGroupHandle
     */
    public native long ifCreateFaceGroup();

    /**
     * insert a face into face group
     * @param[in]  handle               face group handle
     * @param[in]  feature              feature array of one face
     * @param[in]  face_id              face id
     * @return     error code
     */
    public native int ifInsertFaceGroup(long handle, byte[] feature, long face_id);

    /**
     * remove a face from face group
     * @param[in]  handle			Face Group Handle
     * @param[in]  face_id			face id of the face to be remove
     * @return     error code
     */
    public native int ifRemoveFaceGroup(long handle, long face_id);

    /**
     * get the number of faces in group
     * @param[in]	handle				face group handle
     * @return		total_sum			number of faces in group
     */
    public native int ifGetFaceGroupCount(long handle);

    /**
     * clear all faces in the group
     * @param[in]	handle				face group handle
     * @return		error code
     */
    public native int ifResetFaceGroup(long handle);

    /**
     * get most similar face id and similarity score from a face group
     * @param[in]  handle           face group handle
     * @param[in]  target           feature array of target face
     * @param[in]  feature_length   target feature length
     * @return     IFIdentifyResult
     */
    public native IFIdentifyResult ifIdentifyFromFaceGroup(long handle, byte[] feature);

    /**
     * get top k similar face ids and similarity scores from a face group, maximum is 10
     * @param[in]  handle           face group handle
     * @param[in]  target           feature array of target face
     * @param[in]  feature_length   target feature length
     * @param[in]  k                how many results to return, in the interval [1, 10].
     * @return     IFIdentifyResult[]
     */
    public native IFIdentifyResult[] ifTopkFromFaceGroup(long handle, byte[] feature, int k);

    /**
     * release a group
     * @param[in]	handle          face group handle
     * @return		error code
     */
    public native int ifReleaseFaceGroup(long handle);

}




